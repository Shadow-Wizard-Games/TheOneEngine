{
  "fragment": "#version 450 core\n// const int MAX_POINT_LIGHTS = 32;\n// const int MAX_SPOT_LIGHTS = 32;\n\n// struct BaseLight\n// {\n//     vec3 Color;\n//     float AmbientIntensity;\n//     float DiffuseIntensity;\n// };\n\n// struct DirectionalLight\n// {\n//     BaseLight Base;\n//     vec3 Direction;\n// };\n\n// struct Attenuation\n// {\n//     float Constant;\n//     float Linear;\n//     float Exp;\n// };\n\n// struct PointLight\n// {\n//     BaseLight Base;\n//     vec3 LocalPos;\n//     Attenuation Atten;\n// };\n\n// struct SpotLight\n// {\n//     PointLight Base;\n//     vec3 Direction;\n//     float Cutoff;\n// };\n\n// in vec3 v_world_normal;\n// in vec4 v_vertex_color;\nin vec2 v_Vertex_UV;\n\n// in vec3 Normal;\n// in vec3 LocalPos;\n// in vec4 LightSpacePos;\n\n// // Outline percentage\n// uniform vec2 u_OutlineSmoothRange = vec2(0.4,0.4);\n// // Outline color\n// uniform vec4 u_OutlineColor = vec4(0,0,0,1);\n\n// uniform vec4 u_MatAmbientColor;\n// uniform vec4 u_MatDiffuseColor;\n// uniform vec4 u_MatSpecularColor;\n// uniform int u_ToonLevels = 4;\n// uniform float u_RimLightPower = 4.0;\n\n// float ToonScaleFactor = 1.0f / u_ToonLevels;\n\n// uniform DirectionalLight u_DirectionalLight;\n// uniform int u_NumPointLights;\n// uniform PointLight[MAX_POINT_LIGHTS] u_PointLights;\n// uniform int u_NumSpotLights;\n// uniform SpotLight[MAX_SPOT_LIGHTS] u_SpotLights;\n// uniform vec4 u_Color = vec4(0.0,0.0,0.0,0.0);\n// uniform int u_Hit = 0;\n// uniform sampler2D u_ShadowMap;\nuniform sampler2D u_Tex;\n// uniform float u_SpecularValue;\n// uniform vec3 u_CameraPosition;\n// uniform vec3 u_LightPos;\n\nout vec4 FragColor;\n\n// float CalcShadowFactor(vec3 position,vec3 direction)\n// {\n//      vec3 projCoords = LightSpacePos.xyz / LightSpacePos.w;\n//     // transform to [0,1] range\n//     projCoords = projCoords * 0.5 + 0.5;\n//     // get closest depth value from light's perspective (using [0,1] range fragPosLight as coords)\n//     float closestDepth = texture(u_ShadowMap, projCoords.xy).r; \n//     // get depth of current fragment from light's perspective\n//     float currentDepth = projCoords.z;\n//     // calculate bias (based on depth map resolution and slope)\n//     vec3 normal = normalize(Normal);\n//     vec3 lightDir = normalize(position - LocalPos);\n//     float bias = 0.005;\n//     // check whether current frag pos is in shadow\n//     // float shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0;\n//     // PCF\n//     float shadow = 0.0;\n//     vec2 texelSize = 1.0 / textureSize(u_ShadowMap, 0);\n//     for(int x = -1; x <= 1; ++x)\n//     {\n//         for(int y = -1; y <= 1; ++y)\n//         {\n//             float pcfDepth = texture(u_ShadowMap, projCoords.xy + vec2(x, y) * texelSize).r; \n//             shadow += currentDepth - bias > pcfDepth  ? 1.0 : 0.0;        \n//         }    \n//     }\n//     shadow /= 9.0;\n\n//    if(projCoords.z > 1.0)\n//         shadow = 0.0;\n    \n//     return shadow;\n// }\n\n// float CalcRimLightFactor(vec3 pixelToCamera, vec3 normal)\n// {\n//     float rimFactor = dot(pixelToCamera, normal);\n//     rimFactor = 1.0 - rimFactor;\n//     rimFactor = max(0.0, rimFactor);\n//     rimFactor = pow(rimFactor, u_RimLightPower);\n//     return rimFactor;\n// }\n\n// vec4 CalcLightInternal(BaseLight light, vec3 direction, vec3 normal, float shadowFactor)\n// {\n//     vec4 ambientColor = vec4(light.Color, 1.0f) * light.AmbientIntensity * u_MatAmbientColor;\n\n//     float diffuseFactor = dot(normal, -direction);\n\n//     vec4 diffuseColor = vec4(0, 0, 0, 0);\n//     vec4 specularColor = vec4(0, 0, 0, 0);\n//     vec4 rimColor = vec4(0, 0, 0, 0);\n\n//     if(diffuseFactor > 0) \n//     {\n//         diffuseFactor = floor(diffuseFactor * u_ToonLevels) * ToonScaleFactor;\n\n//         diffuseColor = vec4(light.Color, 1.0f) * light.DiffuseIntensity * u_MatDiffuseColor * diffuseFactor;\n\n//         vec3 pixelToCamera = normalize(u_CameraPosition - LocalPos);\n\n//         float rimFactor = CalcRimLightFactor(pixelToCamera, normal);\n//         rimColor = diffuseColor * rimFactor;\n//     }\n\n//     return (ambientColor + (1 - shadowFactor)  * (diffuseColor + specularColor + rimColor));\n// }\n\n// vec4 CalcDirectionalLight(vec3 normal)\n// {\n    \n//     float shadowFactor = CalcShadowFactor(u_LightPos, u_DirectionalLight.Direction);\n\n//     return CalcLightInternal(u_DirectionalLight.Base, u_DirectionalLight.Direction, normal, shadowFactor);\n// }\n\n// vec4 CalcPointLight(PointLight light, vec3 normal)\n// {\n//     float shadowFactor = 1.0;\n\n//     vec3 lightDirection = LocalPos - light.LocalPos;\n//     float distance = length(lightDirection);\n//     lightDirection = normalize(lightDirection);\n\n//     vec4 color = CalcLightInternal(light.Base, lightDirection, normal, shadowFactor);\n\n//     float attenuation = light.Atten.Constant +\n//                         light.Atten.Linear * distance *\n//                         light.Atten.Exp * distance * distance;\n\n//     return color / attenuation;\n// }\n// vec4 CalcSpotLight(SpotLight light, vec3 normal)\n// {\n//     vec3 lightToPixel = normalize(LocalPos - light.Base.LocalPos);\n//     float spotFactor = dot(lightToPixel, light.Direction);\n\n//     if(spotFactor > light.Cutoff)\n//     {\n//         vec4 color = CalcPointLight(light.Base, normal);\n//         float spotLightIntensity = (1.0 - (1.0 - spotFactor) / (1.0 - light.Cutoff));\n//         return color * spotLightIntensity;\n//     }\n// }\n\nvoid main() {\n  \n\n\t//vec3 normal = normalize(Normal);\n\n\t//vec4 totalLight = CalcDirectionalLight(normal);\n\t\n\t// for(int i = 0; i < u_NumPointLights; i++)\n    // {\n    //     totalLight += CalcPointLight(u_PointLights[i], normal);\n    // }\n\n\t// vec3 dir = u_CameraPosition - LocalPos;\n\t\n\t// float dotEyeNormal = dot(normalize(dir),normalize(Normal));\n    // dotEyeNormal = abs(dotEyeNormal);\n\t\n\tvec2 flipuv = vec2(v_Vertex_UV.s, 1. - v_Vertex_UV.t);\n\tFragColor = texture(u_Tex, flipuv);\n\t//flipuv);//ambient * v_vertex_color * \n\t\n\t// vec4 colorLight  = color * totalLight;\n\t// if(u_Hit == 1)\n    // {\n    //     FragColor = u_Color;\n    // }\n    // else{\n\t//     FragColor = mix(u_OutlineColor, colorLight, smoothstep(u_OutlineSmoothRange.x,u_OutlineSmoothRange.y,dotEyeNormal));\n    // }\n}",
  "uniforms": [
    {
      "Name": "u_Tex",
      "Type": 10
    }
  ],
  "vertex": "#version 450 core\n\nlayout(location = 0) in vec2 a_UV;\nlayout(location = 1) in vec3 a_Pos;\nlayout(location = 2) in vec3 a_normal;\nlayout(location = 3) in vec4 a_color;\n\nout vec2 v_Vertex_UV;\n//out vec3 v_world_normal;\n//out vec4 v_vertex_color;\n\n//out vec3 Normal;\n//out vec3 LocalPos;\n//out vec4 LightSpacePos;\n\nlayout(std140, binding = 0) uniform Camera\n{\n\tmat4 u_ViewProjection;\n};\n\nuniform mat4 u_Model;\n\n//uniform mat4 u_LightMVP;\n\nvoid main() {\n\t\n\tgl_Position = u_ViewProjection * u_Model * vec4(a_Pos, 1.0);\n\n\tv_Vertex_UV = a_UV;\n\t\n\t//mat3 cross_matrix = mat3(\n\t//\tcross(u_Model[1].xyz, u_Model[2].xyz),\n\t//\tcross(u_Model[2].xyz, u_Model[0].xyz),\n\t//\tcross(u_Model[0].xyz, u_Model[1].xyz));\n\t\t\n\t//float invdet = 1.0 / dot(cross_matrix[2], u_Model[2].xyz);\n\t//mat3 normal_matrix = cross_matrix * invdet;\n\t\n\t//v_world_normal = normal_matrix * a_normal;\n\t\n\t//v_vertex_color = a_color;\n\t\n\t//Normal =(world_matrix * vec4(a_normal, 0)).xyz;\n\t\n\t//LocalPos = vec3(world_matrix * vec4(a_Pos, 1.0f));\n\n\t//LightSpacePos = u_LightMVP * vec4(LocalPos, 1.0);\n}"
}